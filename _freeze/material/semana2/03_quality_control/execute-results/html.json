{
  "hash": "ad33aedd04e2300d1285cedb5876fb88",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"03 - Controle de qualidade\"\nformat:\n  html:\n    toc: true\n    toc-depth: 3\nexecute: \n  cache: true\n---\n\n\n\n\n## Motivação\n\nAntes de realizar qualquer análise exploratória ou inferência estatística com dados de RNA-seq de célula única (scRNA-seq), é essencial garantir que os dados sejam de **alta qualidade**. Diferentemente do RNA-seq convencional (bulk), dados de scRNA-seq são altamente suscetíveis a **ruído técnico** e **artefatos experimentais**, como células mortas, dupletos e contaminação por RNA ambiente.\n\n## Contextualização\n\nDados de RNA-seq de célula única (scRNA-seq) são poderosos para investigar a heterogeneidade celular, mas exigem um rigoroso controle de qualidade devido à presença de ruídos técnicos, células danificadas, dupletos e contaminação por RNA ambiente.\n\nNeste tutorial, utilizamos um conjunto de ferramentas complementares:\n\n-   **`Seurat`** para pré-processamento, cálculo de métricas de qualidade e filtragem de células;\n-   **`SoupX`** para identificar e corrigir contaminação por RNA ambiente (ambient RNA);\n-   **`scDblFinder`** para detectar e remover dupletos (*doublets*).\n\nA aplicação combinada desses pacotes permite construir um conjunto de células de alta qualidade, garantindo que análises posteriores — como clusterização e anotação de tipos celulares — sejam mais robustas e confiáveis.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Seurat)\nlibrary(scDblFinder)\nlibrary(dplyr)\nlibrary(here)\nlibrary(patchwork)\n\n# Definindo diretorio padrao\nknitr::opts_knit$set(\n  root.dir = \"/home/oandrefonseca/Disciplinas/PPGBM0117.2025.1\",\n  verbose = FALSE\n)\n```\n:::\n\n\n\n\n## O que é Seurat?\n\nSeurat é um pacote R desenvolvido para controle de qualidade, análise e exploração de dados de RNA-sequenciamento de células individuais. Seurat visa permitir que os usuários identifiquem e interpretem fontes de heterogeneidade a partir de medições transcriptômicas de células individuais e integrem diversos tipos de dados de células individuais. Para mais detalhes acesse [aqui](https://satijalab.org/seurat/).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreast_data <- Read10X(\n  data.dir = here::here(\"data/filtered_feature_bc_matrix/\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- CreateSeuratObject(\n  counts = breast_data, project = \"Breast_7k\")\n```\n:::\n\n\n\n\n## Estrutura do Objeto `Seurat`\n\nPara visualizar a estrutura do objeto recém-construídos, podemos utilizar o comando:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exibe de forma compacta a estrutura interna de um objeto R\nstr(seurat_object)\n```\n:::\n\n\n\n\n| Slot | Tipo de Objeto | Descrição |\n|----------------------------|--------------------------|------------------|\n| `assays` | Lista de `Assay` | Armazena dados de expressão para diferentes modalidades (e.g., RNA, ATAC). Cada `Assay` contém camadas como `counts`, `data` e `scale.data`. |\n| `meta.data` | `data.frame` | Metadados por célula, como `nFeature_RNA`, `nCount_RNA`, `percent.mt`, entre outros. |\n| `active.assay` | `character` | Nome do `Assay` ativo, utilizado por funções padrão como `NormalizeData()`. |\n| `active.ident` | `factor` | Identidade celular ativa, geralmente usada para clusterização e visualizações. |\n| `reductions` | Lista de `DimReduc` | Armazena resultados de reduções dimensionais, como PCA, UMAP e t-SNE. |\n| `graphs` | Lista de `Graph` | Contém grafos de vizinhança utilizados em algoritmos de clusterização, como `FindNeighbors()`. |\n| `neighbors` | Lista | Armazena informações sobre vizinhos mais próximos calculados, úteis para métodos como UMAP. |\n| `images` | Lista de `SpatialImage` | Armazena dados de imagens espaciais, como os provenientes de experimentos Visium. |\n| `project.name` | `character` | Nome do projeto associado ao objeto `Seurat`. |\n| `misc` | Lista | Informações diversas e adicionais que não se encaixam nos outros slots. |\n| `version` | `package_version` | Versão do pacote `Seurat` utilizada para criar o objeto. |\n| `commands` | Lista de `SeuratCommand` | Histórico de comandos aplicados ao objeto, incluindo parâmetros e timestamps. |\n| `tools` | Lista | Resultados de análises adicionais geradas por outras ferramentas, preenchido por desenvolvedores usando `Tool<-`. |\n\n::: {.callout-note collapse=\"false\"}\nA estrutura do objeto `Seurat` pode **sofrer pequenas alterações entre versões do pacote**, especialmente em relação à organização interna dos slots, nomenclatura e slots adicionais utilizados por novos métodos.\n\nEste tutorial foi desenvolvido com a versão **Seurat 5.2.1**, na qual os principais componentes do objeto — como `assays`, `meta.data`, `reductions`, `graphs` e `commands` — mantêm compatibilidade com versões anteriores, mas apresentam melhorias de desempenho e integração com múltiplas modalidades.\n:::\n\n## Descrevendo o metadata\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(seurat_object@meta.data)\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\n-   **Número total de moleculas unicas (`nCount_RNA`)**\\\n-   **Número de genes detectados (`nFeature_RNA`)**\\\n:::\n\n## Avaliação da qualidade das células\n\n### Calculando percentagem relacionada a genes de interesse\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Genes mitocondriais (nomes iniciam com \"MT-\")\nseurat_object[[\"percent.mt\"]] <- PercentageFeatureSet(\n  seurat_object, pattern = \"^MT-\")\n\n# Genes ribossômicos (nomes iniciam com \"RPS\" ou \"RPL\")\nseurat_object[[\"percent.ribo\"]] <- PercentageFeatureSet(\n  seurat_object, pattern = \"^RP[SL]\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Genes de hemoglobina - remover HBP explicitamente\nhb_genes <- grep(\"^HB\", rownames(seurat_object), value = TRUE)\nhb_genes <- hb_genes[!grepl(\"^HBP\", hb_genes)]\n\nseurat_object[[\"percent.hb\"]] <- PercentageFeatureSet(\n  seurat_object, features = hb_genes)\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\nEssas porcentagens ajudam a:\n\n-   **Filtrar células de baixa qualidade** (ex: alto `percent.mt`);\n-   **Identificar artefatos ou contaminações** (ex: glóbulos vermelhos via `percent.hb`);\n-   **Detectar viés técnico** ou diferenças biológicas significativas (ex: via `percent.ribo`).\n\nEssas métricas são frequentemente visualizadas via `VlnPlot()` ou correlacionadas com `nCount_RNA` para detectar padrões suspeitos.\n:::\n\n### Salvando estatísticas pré-filtragem\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npre_qc_stats <- data.frame(\n  number_of_cells = ncol(seurat_object),\n  mean_counts_per_cell = mean(seurat_object$nCount_RNA),\n  median_counts_per_cell = median(seurat_object$nCount_RNA),\n  mean_features_per_cell = mean(seurat_object$nFeature_RNA),\n  median_features_per_cell = median(seurat_object$nFeature_RNA)\n)\n```\n:::\n\n\n\n\n### Visualizando métricas de interesse\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- VlnPlot(seurat_object, \n        features = c(\"nCount_RNA\", \"nFeature_RNA\"), ncol = 3)\n\np2 <- VlnPlot(seurat_object, \n        features = c(\"percent.mt\", \"percent.ribo\", \"percent.hb\"), ncol = 3)\n\np1\np2\n```\n\n::: {.cell-output-display}\n![](03_quality_control_files/figure-html/fig-quality-metrics-1.png){#fig-quality-metrics-1 fig-align='center' width=672}\n:::\n\n::: {.cell-output-display}\n![](03_quality_control_files/figure-html/fig-quality-metrics-2.png){#fig-quality-metrics-2 fig-align='center' width=672}\n:::\n:::\n\n\n\n\n### Correlacionando métricas\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-nrow=\"1\"}\n\n```{.r .cell-code}\nplot1 <- FeatureScatter(seurat_object, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 <- FeatureScatter(seurat_object, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\n\nplot1\nplot2\n```\n\n::: {.cell-output-display}\n![](03_quality_control_files/figure-html/fig-quality-correlation-1.png){#fig-quality-correlation-1 width=672}\n:::\n\n::: {.cell-output-display}\n![](03_quality_control_files/figure-html/fig-quality-correlation-2.png){#fig-quality-correlation-2 width=672}\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\n1.  **`nCount_RNA` vs. `nFeature_RNA`**\\\n    Uma **correlação positiva forte** é esperada: quanto maior o número total de transcritos, maior tende a ser o número de genes detectados.\\\n    → Uma correlação **anormalmente fraca** pode indicar problemas técnicos ou presença de dupletos.\n\n2.  **`nCount_RNA` vs. `percent.mt`**\\\n    Geralmente apresentam uma **correlação negativa**. Células com um número total maior de moléculas de RNA (alto nCount_RNA) são tipicamente associadas a uma porcentagem menor de leituras mitocondriais (menor percent.mt), indicando melhor qualidade celular e menos contaminação.\n    → Uma **alta percentagem mitocondrial com poucos counts** pode ser um sinal de apoptose ou lise celular.\n:::\n\n### Identificando limiares de corte\n\nEsta função permite identificar **células com valores extremos** para uma métrica contínua, como `nFeature_RNA` ou `percent.mt`, utilizando um critério estatístico baseado em:\n\n> **mediana ± (n × MAD)**\n\nEssa abordagem é **mais robusta que o desvio padrão**, pois é menos sensível a valores extremos.  \nO argumento `nmads` controla a sensibilidade da filtragem (3 é o valor comumente utilizado).\n\nEsta função é útil para **detectar e remover artefatos experimentais** ou células anômalas de forma personalizada.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_outlier <- function(seurat_object, metric, nmads = 3, verbose = TRUE) {\n  # Extrai os valores da métrica desejada\n  values <- seurat_object@meta.data[[metric]]\n\n  # Calcula mediana e desvio absoluto da mediana (MAD)\n  med <- median(values, na.rm = TRUE)\n  mad_val <- mad(values, center = med, constant = 1, na.rm = TRUE)\n\n  # Define os thresholds inferior e superior\n  lower <- med - nmads * mad_val\n  upper <- med + nmads * mad_val\n\n  # Imprime os limites, se verbose = TRUE\n  if (verbose) {\n    message(glue::glue(\"Outliers para '{metric}' definidos como valores fora do intervalo:\"))\n    message(glue::glue(\"  Inferior: {round(lower, 2)}\"))\n    message(glue::glue(\"  Superior: {round(upper, 2)}\"))\n  }\n\n  # Identifica outliers\n  outlier <- (values < lower) | (values > upper)\n  return(outlier)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object$mt_outlier <- is_outlier(\n  seurat_object, metric = \"percent.mt\", nmads = 3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nOutliers para 'percent.mt' definidos como valores fora do intervalo:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  Inferior: -15.07\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  Superior: 41.41\n```\n\n\n:::\n\n```{.r .cell-code}\ntable(seurat_object$mt_outlier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n 3719  1961 \n```\n\n\n:::\n:::\n\n\n\n\n## Identificando dupletos\n\n**Dupletos (doublets)** ocorrem quando duas células distintas são capturadas dentro da mesma gotícula durante a etapa de microencapsulamento (como no 10x Genomics). Como resultado, seus perfis transcriptômicos são combinados e registrados como uma única célula.\n\n### Por que isso é um problema?\n\n- Dupletos podem **formar clusters artificiais** ou **preencher espaços entre populações reais**, confundindo a interpretação biológica.\n- Em análises downstream, como **clusterização**, **diferenciação de tipos celulares** e **descoberta de trajetórias**, os dupletos introduzem **ruído**.\n\nFerramentas como **`scDblFinder`**, **`Scrublet`** e **`DoubletFinder`** utilizam estratégias estatísticas e simulações para identificar prováveis dupletos com base na similaridade de perfis de expressão e distribuição de vizinhos.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Converta o objeto Seurat para SingleCellExperiment\nsce <- as.SingleCellExperiment(seurat_object)\n\n# Executa a identificação de dupletos\nsce <- scDblFinder(sce)\n\n# Adiciona o resultado de volta ao objeto Seurat\nseurat_object$scDblFinder.class <- sce$scDblFinder.class\nseurat_object$doublet_score <- sce$scDblFinder.score\n\n# Visualiza a proporção de dupletos identificados\ntable(seurat_object$scDblFinder.class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nsinglet doublet \n   5203     477 \n```\n\n\n:::\n:::\n\n\n\n\n## Filtrando células de baixa qualidade\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Criando copia do objeto pre-filtragem\npre_seurat_object <- seurat_object\n\n# Filtro com thresholds definidos manualmente\nseurat_object <- subset(\n  seurat_object,\n  subset = nFeature_RNA > 200 &\n           nFeature_RNA < 6000 &\n           percent.mt < 10 &\n           scDblFinder.class == \"singlet\"\n)\n```\n:::\n\n\n\n\n### Salvando estatística pós-filtragem\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Estatísticas após o QC\npost_qc_stats <- data.frame(\n  number_of_cells = ncol(seurat_object),\n  mean_counts_per_cell = mean(seurat_object$nCount_RNA),\n  median_counts_per_cell = median(seurat_object$nCount_RNA),\n  mean_features_per_cell = mean(seurat_object$nFeature_RNA),\n  median_features_per_cell = median(seurat_object$nFeature_RNA)\n)\n```\n:::\n\n\n\n\n### Combinando as estatísticas pré e pós-filtragem\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Unindo as tabelas\nqc_summary <- rbind(\n  cbind(Etapa = \"Antes do QC\", pre_qc_stats),\n  cbind(Etapa = \"Depois do QC\", post_qc_stats)\n)\n```\n:::\n\n\n\n\n## Comparando antes e depois\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-nrow=\"1\"}\n\n```{.r .cell-code}\nDT::datatable(qc_summary)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-f843a680a1fcd62a0dd1\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-f843a680a1fcd62a0dd1\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\"],[\"Antes do QC\",\"Depois do QC\"],[5680,1666],[20342.68221830986,24193.98679471789],[11498,25982],[3046.132042253521,4141.81212484994],[2610.5,4640.5]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>Etapa<\\/th>\\n      <th>number_of_cells<\\/th>\\n      <th>mean_counts_per_cell<\\/th>\\n      <th>median_counts_per_cell<\\/th>\\n      <th>mean_features_per_cell<\\/th>\\n      <th>median_features_per_cell<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[2,3,4,5,6]},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"Etapa\",\"targets\":1},{\"name\":\"number_of_cells\",\"targets\":2},{\"name\":\"mean_counts_per_cell\",\"targets\":3},{\"name\":\"median_counts_per_cell\",\"targets\":4},{\"name\":\"mean_features_per_cell\",\"targets\":5},{\"name\":\"median_features_per_cell\",\"targets\":6}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false},\"selection\":{\"mode\":\"multiple\",\"selected\":null,\"target\":\"row\",\"selectable\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n## Normalização — Protocolo padrão\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- NormalizeData(\n  seurat_object, normalization.method = \"LogNormalize\", scale.factor = 10000)\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\nA normalização é uma etapa fundamental no pré-processamento de dados de célula única. Ela tem como objetivo **corrigir variações na profundidade de sequenciamento entre células**\n\nMétodos disponíveis no argumento `normalization.method`:\n\n-   \"LogNormalize\": método padrão, baseado em normalização por profundidade e log-transformação;\n-   \"CLR\" (Centered Log-Ratio): útil para dados de proteínas ou marcadores em CITE-seq;\n-   \"RC\" (Relative Counts): contagens relativas sem transformação logarítmica;\n-   \"SCT\": normalização baseada em modelos estatísticos via SCTransform() (mais avançado, recomendado para integração de dados).\n:::\n\n### Encontrando genes com alta variabilidade\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\nseurat_object <- FindVariableFeatures(\n  seurat_object, selection.method = \"vst\", nfeatures = 2000)\n\n# Identify the 10 most highly variable genes\ntop10 <- head(VariableFeatures(seurat_object), 10)\n\n# plot variable features with and without labels\nplot1 <- VariableFeaturePlot(seurat_object)\nplot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)\n\nplot2\n```\n\n::: {.cell-output-display}\n![](03_quality_control_files/figure-html/fig-highly-variable-genes-1.png){#fig-highly-variable-genes fig-align='center' width=672}\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\nO código abaixo identifica os **genes com maior variabilidade de expressão** entre as células, que são mais informativos para análises downstream como **PCA, clusterização e UMAP**.\n\n-   `selection.method`: O método **vst** é baseado em transformação de variância estabilizada (log-linear), ideal para scRNA-seq;\n-   `nfeatures`: quantidade de genes a serem mantidos como \"altamente variáveis\".\n:::\n\n### Ajustando escala dos dados\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- ScaleData(seurat_object)\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\nA função `ScaleData()` realiza a **padronização dos dados de expressão gênica**, centralizando os valores (subtraindo a média) e escalando pela variância (dividindo pelo desvio padrão) para cada gene.\n\nEssa etapa é essencial para técnicas como **PCA e clustering**, pois garante que todos os genes contribuam igualmente, independentemente da magnitude de sua expressão.\n:::\n\n## Normalização - SCTransform\n\nJá o **`SCTransform()`** substitui essas três etapas com um único comando baseado em um **modelo estatístico de regressão negativa binomial**, que:\n\n- Normaliza os dados levando em conta a variância técnica estimada;\n- Identifica genes variáveis de forma mais robusta;\n- Corrige efeitos indesejados (como % de genes mitocondriais ou batch effect) diretamente no modelo;\n- Retorna dados já escalados e prontos para PCA.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- SCTransform(\n  seurat_object, vars.to.regress = \"percent.mt\", verbose = FALSE)\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\nO argumento `vars.to.regress` permite **remover o efeito de variáveis indesejadas** — como porcentagem de transcritos mitocondriais (`percent.mt`), ciclo celular ou batch — durante a modelagem estatística realizada pelo `SCTransform()`. Para mais detalhes, por favor acesso o [link](https://satijalab.org/seurat/articles/sctransform_vignette)\n:::\n\n## Redução de dimensionalidade\n\nDados de scRNA-seq possuem **altíssima dimensionalidade**, com milhares de genes medidos por célula. Trabalhar diretamente com todas essas dimensões é:\n\n- **Computacionalmente ineficiente**;\n- **Propenso a ruído** (a maioria dos genes não é informativa para variação biológica relevante);\n- **Inadequado para visualização** e interpretação humana.\n\nA redução de dimensionalidade, como **PCA (análise de componentes principais)** ou **UMAP (projeção para espaço não linear)**, nos permite **resumir os dados em eixos principais de variação**, destacando padrões estruturais — como **grupos celulares, trajetórias ou batch effects** — enquanto minimizamos a influência de ruídos técnicos.\n\nEssa etapa é essencial para **visualização**, **clusterização** e **modelagem de trajetórias** em análises de transcriptômica de célula única.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- RunPCA(\n  seurat_object, assay = \"RNA\", reduction.name = \"STD_PCA\", features = VariableFeatures(object = seurat_object))\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\n\nO argumento `reduction.name` permite **nomear explicitamente o resultado da redução de dimensionalidade**, neste caso, da análise de componentes principais (PCA). Por padrão, o Seurat armazena o PCA no slot `\"pca\"`, mas ao especificar:\n\n:::\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-align=\"center\"}\n\n```{.r .cell-code}\n# Examine and visualize PCA results a few different ways\nVizDimLoadings(seurat_object, dims = 1:2, reduction = \"STD_PCA\")\n```\n\n::: {.cell-output-display}\n![](03_quality_control_files/figure-html/fig-pc-loadings-1.png){#fig-pc-loadings fig-align='center' width=672}\n:::\n:::\n\n\n\n\n## Projeção com UMAP\n\nO **UMAP (Uniform Manifold Approximation and Projection)** é uma técnica de redução de dimensionalidade **não linear** amplamente utilizada para **visualizar dados de scRNA-seq**.\n\nEle projeta células de um espaço de milhares de genes para **2D ou 3D**, preservando **estruturas locais e globais** dos dados. Isso facilita a identificação visual de **subpopulações celulares, transições fenotípicas** e possíveis **trajetórias biológicas**, sendo especialmente útil após PCA.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- RunUMAP(\n  seurat_object, reduction = \"STD_PCA\", umap.method = \"umap-learn\", reduction.name = \"STD_UMAP\", dims = 1:20, verbose = FALSE)\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\n\nO parâmetro `umap.method = \"umap-learn\"` especifica que o Seurat deve usar a **implementação original do UMAP em Python**, fornecida pelo pacote [`umap-learn`](https://github.com/lmcinnes/umap).\n\nEssa versão tende a produzir **projeções mais estáveis e refinadas** do que a implementação padrão em R, especialmente em datasets grandes ou com estrutura complexa. Para funcionar, é necessário ter o Python instalado com o pacote `umap-learn` disponível via `reticulate`.\n\n:::\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-align=\"center\"}\n\n```{.r .cell-code}\nDimPlot(seurat_object, reduction = \"STD_UMAP\")\n```\n\n::: {.cell-output-display}\n![](03_quality_control_files/figure-html/fig-umap-plot-1.png){#fig-umap-plot fig-align='center' width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}