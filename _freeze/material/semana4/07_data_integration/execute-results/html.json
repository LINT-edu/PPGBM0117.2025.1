{
  "hash": "5d95cdd5738d567d3ce917c7b6331bbe",
  "result": {
    "engine": "knitr",
    "markdown": " ---\ntitle: \"07 - Integração de dados\"\nformat:\n  html:\n    toc: true\n    toc-depth: 3\nexecute:\n  cache: false\n\n---\n\n## Motivação\n\nA integração de dados de transcriptômica de célula única é crucial para mitigar efeitos de batch e possibilitar análises comparativas robustas entre diferentes amostras, tecnologias ou condições experimentais. Seurat v5 simplifica esse processo com suporte a múltiplos métodos de integração e estrutura moderna baseada em camadas.\n\n## Contextualização\n\nNeste tutorial, exploramos abordagens modernas para **integração de dados scRNA-seq**, com foco em métodos implementados ou compatíveis com o pacote `Seurat` e suas extensões. A integração é fundamental para eliminar variações técnicas (batch effects) e permitir a comparação significativa entre múltiplas amostras ou tecnologias.\n\nOs métodos empregados podem ser classificados da seguinte forma:\n\n-   **Integração baseada em âncoras canônicas (CCA)** – método nativo do Seurat para identificar correspondências entre subespaços compartilhados entre amostras;\n-   **Integração baseada em redução robusta de dimensionalidade (RPCA)** – alternativa mais rápida e conservadora ao CCA;\n-   **Métodos baseado em regressão no espaço latente (Harmony)** – utiliza regressão em espaços latentes para alinhar células de diferentes batches;\n-   **Integração por vizinhos mútuos (MNN)** – implementado via pacote `batchelor`, baseado em correspondência de vizinhos próximos entre datasets;\n-   **Avaliação de batch effect com métricas** – usada para quantificar a eficiência da remoção de efeito de batch sem perda de estrutura biológica.\n\nEste conjunto de ferramentas permite executar pipelines flexíveis, comparar métodos e validar a integração com métricas objetivas.\n\n## Ajustar ambientar e carregar pacotes\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Carregar pacotes\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(Seurat)\nlibrary(SeuratWrappers)\nlibrary(harmony)\nlibrary(batchelor)\nlibrary(scPOP)\n\n# remotes::install_github('satijalab/seurat-wrappers')\n# devtools::install_github(\"immunogenomics/harmony\", build_vignettes=TRUE)\n# BiocManager::install(\"batchelor\")\n# devtools::install_github('vinay-swamy/scPOP')\n\n# Definindo diretorio padrao\nknitr::opts_knit$set(\n  root.dir = \"/home/oandrefonseca/Disciplinas/PPGBM0117.2025.1\",\n  verbose = FALSE\n)\n\n# Aumentar o limite de uso de memoria\noptions(future.globals.maxSize = 10 * 1024^3) # 10 GB, por exemplo\n```\n:::\n\n\n\n\n## Carregando dados do projeto\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Carregue seu objeto Seurat\nseurat_object <- readRDS(file = here::here(\"data/seurat_multi_technology.RDS\"))\n```\n:::\n\n\n\n\n## Pré-processamento\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object[[\"RNA\"]] <- split(seurat_object[[\"RNA\"]], f = seurat_object$kit)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- NormalizeData(\n  seurat_object, normalization.method = \"LogNormalize\", scale.factor = 10000)\n\nseurat_object <- FindVariableFeatures(\n  seurat_object, selection.method = \"vst\", nfeatures = 2000)\n\nseurat_object <- ScaleData(\n  seurat_object, features = VariableFeatures(seurat_object))\n\nseurat_object <- RunPCA(seurat_object, npcs = 50, verbose = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- FindNeighbors(seurat_object, dims = 1:20)\n\nseurat_object <- FindClusters(\n  seurat_object, \n  cluster.name = \"unintegrated_clusters\",\n  resolution = 0.25\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 23250\nNumber of edges: 837879\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9596\nNumber of communities: 17\nElapsed time: 3 seconds\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- RunUMAP(\n  seurat_object, \n  dims = 1:20, \n  reduction = \"pca\", \n  reduction.name = \"umap.unintegrated\"\n  )\n```\n:::\n\n\n\n\n## Visualizando UMAP\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\n# Verificar os clusters\nDimPlot(seurat_object, group.by = \"kit\")\n```\n\n::: {.cell-output-display}\n![](07_data_integration_files/figure-html/fig-umap-unintegrated-1.png){#fig-umap-unintegrated fig-align='center' width=768}\n:::\n:::\n\n\n\n\n## Integração com diferentes métodos\n\nNesta etapa, aplicaremos diferentes estratégias de integração de dados scRNA-seq implementadas no Seurat v5. Serão utilizados métodos representativos de distintas abordagens: modelos lineares (CCA, RPCA), métodos baseados em regressão latente (Harmony) e correspondência de vizinhos mútuos (FastMNN). O objetivo é comparar como cada técnica corrige o efeito de batch ao alinhar células provenientes de diferentes plataformas (Platform).\n\n### CCA\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- IntegrateLayers(\n  object = seurat_object, \n  method = CCAIntegration,\n  orig.reduction = \"pca\", \n  new.reduction = \"integrated.cca\",\n  verbose = FALSE\n)\n```\n:::\n\n\n\n\n::: {.callout-note collapse=\"false\"}\nA função `IntegrateLayers` do Seurat v5 permite aplicar diferentes estratégias de integração de dados em uma única linha de código. Ela opera sobre uma redução de dimensionalidade inicial (ex: PCA) e retorna uma nova representação integrada, facilitando a comparação entre métodos como CCA, RPCA, Harmony e FastMNN. Essa abordagem é útil para\n:::\n\n### RPCA\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- IntegrateLayers(\n  object = seurat_object, \n  method = RPCAIntegration,\n  orig.reduction = \"pca\", \n  new.reduction = \"integrated.rpca\",\n  verbose = FALSE\n)\n```\n:::\n\n\n\n\n### Harmony\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- IntegrateLayers(\n  object = seurat_object, \n  method = HarmonyIntegration,\n  orig.reduction = \"pca\", \n  new.reduction = \"harmony\",\n  verbose = FALSE\n)\n```\n:::\n\n\n\n\n### FastMNN\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_object <- IntegrateLayers(\n  object = seurat_object, \n  method = FastMNNIntegration,\n  orig.reduction = \"pca\", \n  new.reduction = \"integrated.mnn\",\n  verbose = FALSE\n)\n```\n:::\n\n\n\n\n## Pós-processamento e clustering\n\nApós a integração, aplicamos uma etapa padronizada de pós-processamento para cada método. Isso inclui a construção da matriz de vizinhança, detecção de comunidades (clustering) e projeção UMAP para visualização. Essa abordagem permite comparar diretamente como cada método de integração influencia a estrutura dos dados e a separação entre populações celulares.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vetor com os nomes das reduções geradas por cada método de integração\nintegration_method_vector <- c('integrated.cca', 'integrated.rpca', 'harmony', 'integrated.mnn')\n\nfor (batch_method in integration_method_vector) {\n  \n  # Encontrar vizinhos com base na redução integrada\n  seurat_object <- FindNeighbors(\n    object = seurat_object, \n    reduction = batch_method, \n    dims = 1:50,\n    graph.name = 'snn_npc_0.25'\n  )\n\n  # Realizar clusterização com base no grafo construído\n  seurat_object <- FindClusters(\n    object = seurat_object,\n    graph.name = 'snn_npc_0.25',\n    cluster.name = paste0(batch_method, '_clusters'),\n    resolution = 0.25\n  )\n  \n  # Gerar redução UMAP a partir do embedding integrado\n  seurat_object <- RunUMAP(\n    object = seurat_object,\n    reduction.key = \"umap_\",\n    reduction = batch_method, \n    dims = 1:50,\n    reduction.name = paste0(\"umap_\", batch_method),\n    seed.use = 42\n  )\n  \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 23250\nNumber of edges: 191612\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9284\nNumber of communities: 221\nElapsed time: 1 seconds\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 23250\nNumber of edges: 229042\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9266\nNumber of communities: 59\nElapsed time: 1 seconds\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 23250\nNumber of edges: 238648\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9325\nNumber of communities: 39\nElapsed time: 1 seconds\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 23250\nNumber of edges: 211884\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9289\nNumber of communities: 76\nElapsed time: 1 seconds\n```\n\n\n:::\n:::\n\n\n\n\n## Visualizações comparativas\n\nApós a aplicação dos diferentes métodos de integração e suas respectivas projeções UMAP, é importante comparar visualmente como cada abordagem organizou as células no espaço latente. A seguir, utilizamos DimPlot para gerar um gráfico UMAP para cada técnica, destacando a distribuição das amostras por batch. Isso permite avaliar qualitativamente o grau de correção do efeito de batch e a preservação da estrutura biológica.\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\n# Lista para armanezar as imagens geradas para cada integração\nintegration_umap <- list()\n\nfor (batch_method in integration_method_vector) {\n\n  # Armazenar o gráfico UMAP correspondente ao método atual\n  integration_umap[[batch_method]] <- DimPlot(\n      seurat_object, \n      reduction = paste0(\"umap_\", batch_method),\n      group.by = 'kit',\n      raster = FALSE,\n    ) +\n    labs(title = batch_method) + \n    theme(\n      legend.position = 'top',\n      legend.justification = 'center'\n    )\n  \n}\n\n# Exibir cada um dos gráficos UMAP integrados individualmente\nintegration_umap$integrated.cca\nintegration_umap$integrated.rpca\nintegration_umap$harmony\nintegration_umap$integrated.mnn\n```\n\n::: {.cell-output-display}\n![](07_data_integration_files/figure-html/fig-integrated-umap-1.png){#fig-integrated-umap-1 fig-align='center' width=576}\n:::\n\n::: {.cell-output-display}\n![](07_data_integration_files/figure-html/fig-integrated-umap-2.png){#fig-integrated-umap-2 fig-align='center' width=576}\n:::\n\n::: {.cell-output-display}\n![](07_data_integration_files/figure-html/fig-integrated-umap-3.png){#fig-integrated-umap-3 fig-align='center' width=576}\n:::\n\n::: {.cell-output-display}\n![](07_data_integration_files/figure-html/fig-integrated-umap-4.png){#fig-integrated-umap-4 fig-align='center' width=576}\n:::\n:::\n\n\n\n\n::: {.callout-warning collapse=\"false\"}\nEmbora as visualizações UMAP sejam úteis para inspeção inicial, elas representam apenas uma projeção bidimensional de dados de alta dimensão. Essa abordagem qualitativa pode induzir a interpretações equivocadas sobre a real separação entre populações celulares ou a eficácia da correção de batch. Por isso, é recomendável complementar essas análises com métricas quantitativas, como kBET, LISI ou ARI, que oferecem avaliações mais robustas da integração.\n:::\n\n## Avaliação com métricas\n\nA inspeção visual por UMAP é uma ferramenta útil, mas insuficiente para avaliar com rigor a qualidade da integração. Para isso, é recomendável aplicar métricas quantitativas que estimem de forma objetiva o balanceamento entre batches e a preservação da estrutura biológica.\n\nNo trecho abaixo, utilizamos a função `run_all_metrics()`, que executa um conjunto de métricas baseadas nos embeddings gerados por cada método de integração. Essas métricas consideram tanto a capacidade de mistura entre batches (batch mixing) quanto a manutenção de agrupamentos biológicos definidos por anotações celulares e clusters.\n\nComo complemento opcional, pode-se empregar o teste kBET, que avalia a homogeneidade local de vizinhança entre batches. Apesar de útil, seu uso depende de ajustes específicos e pode ser computacionalmente mais custoso.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data.frame vazio para armazenas as metricas\nmetrics_df <- data.frame()\n\nfor (batch_method in integration_method_vector) {\n  \n  # Extrair as coordenadas de embedding do método de integração\n  batch_method_embeddings <- Embeddings(\n    object = seurat_object, \n    reduction = batch_method\n  )\n  \n  # Calculando métricas a partir do pacote scPOP\n  metrics <- run_all_metrics(\n    reduction = batch_method_embeddings, \n    metadata = seurat_object@meta.data,\n    batch_key = 'kit',\n    label1_key = 'cell_type',\n    label2_key = paste0(batch_method, '_clusters'),\n    run_name = batch_method\n    )\n  \n  colnames(metrics) <- c(\"run\", \"ari_label\", \"nmi_label\", \"lisi_batch\", \"lisi_cell_type\", \"lisi_clusters\", \"silWidth_batch\", \"silWidth_cell_type\", \"silWidth_clusters\")\n    \n  metrics_df <- rbind(\n    metrics,\n    metrics_df\n  )\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nscpop_zscore <- calc_sumZscore(\n  lapply(integration_method_vector, function(batch_method) {\n    metrics_df[metrics_df$run == batch_method, 2:9]\n  }),\n  'kit'\n)\n\nmetrics_df$zscore <- scpop_zscore\n```\n:::\n\n::: {.cell .column-screen-inset-shaded}\n\n```{.r .cell-code}\n# Explore as metricas\nDT::datatable(metrics_df)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-51bbca33135113b055d0\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-51bbca33135113b055d0\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\"],[\"integrated.mnn\",\"harmony\",\"integrated.rpca\",\"integrated.cca\"],[0.7247691931302062,0.6970376987118977,0.8741011913271709,0.8664242650106361],[0.7521842778335154,0.7302016655628628,0.8208779838662594,0.8106467110791098],[1.526040896706034,1.893480481785342,2.025193594122998,2.007274489631637],[1.096848000580873,1.107119132517484,1.106134726340539,1.109981558768962],[1.048950109345057,1.053596902348044,1.031376207030882,1.031827112662981],[0.0176085550640283,-0.01104376503836495,-0.01868955473475107,-0.01863285977787174],[0.2810464919309717,0.2844268134682653,0.3178547558600563,0.3324072109041926],[0.2629230959656497,0.2511574028327897,0.3408018750163478,0.177859440574773],[-0.6411554616447307,2.091193348049168,-3.722116225047441,2.272078338643102]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>run<\\/th>\\n      <th>ari_label<\\/th>\\n      <th>nmi_label<\\/th>\\n      <th>lisi_batch<\\/th>\\n      <th>lisi_cell_type<\\/th>\\n      <th>lisi_clusters<\\/th>\\n      <th>silWidth_batch<\\/th>\\n      <th>silWidth_cell_type<\\/th>\\n      <th>silWidth_clusters<\\/th>\\n      <th>zscore<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[2,3,4,5,6,7,8,9,10]},{\"orderable\":false,\"targets\":0},{\"name\":\" \",\"targets\":0},{\"name\":\"run\",\"targets\":1},{\"name\":\"ari_label\",\"targets\":2},{\"name\":\"nmi_label\",\"targets\":3},{\"name\":\"lisi_batch\",\"targets\":4},{\"name\":\"lisi_cell_type\",\"targets\":5},{\"name\":\"lisi_clusters\",\"targets\":6},{\"name\":\"silWidth_batch\",\"targets\":7},{\"name\":\"silWidth_cell_type\",\"targets\":8},{\"name\":\"silWidth_clusters\",\"targets\":9},{\"name\":\"zscore\",\"targets\":10}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false},\"selection\":{\"mode\":\"multiple\",\"selected\":null,\"target\":\"row\",\"selectable\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n## Salvando o objeto anotado\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(seurat_object, file = './data/seurat_integrated.RDS')\n```\n:::\n",
    "supporting": [
      "07_data_integration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}